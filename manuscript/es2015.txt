# es2015

* This appendix covers converting the components we created into es2015 syntax.
* This is not required to use React. But the newer syntax is much more pleasant.
* Not all of ES2015 is supported in all browsers. For production apps, be sure to have a build step where you transform ES2015 into ES5.
  * The most common transformer is Babel.

## Greeting

Let's start with the Greeting component.

We can use 2 new features to improve the component.
* const
* arrow functions
* implicit returns
* destructuring

### Const
First, we'll change the `var` keywoard to `const`. Const ensures that `Greeting` can't be reassigned in this scope. We'll get an error if we try.

```
const Greeting = function (props) {
  return <div>{props.name}</div>
}
```

### Arrow Functions
Next, we can take advantage of arrow functions to remove the function keyword. There's nothing wrong with function but arrow functions are more terse and demonstrate, with syntax that these are lambda functions.

```
const Greeting = (props) => {
  return <div>{props.name}</div>
}
```

### Arrow Functions implicit returns
Thirdly, arrow functions have an implicit return. The rules around this can be tricky. But you can always use it to return a React component.
(Note that at least the opening `<div>` needs to be on the same line as the assignment.)

```
const Greeting = (props) => <div>{props.name}</div>
```

### Destructuring Assignment
Finally, we can use destructuring assignment to extract just the properties we want from the props object.
This is not wholly necessary in this particular component but it's a pattern you might see a lot.

```
const Greeting = ({ name }) => <div>{name}</div>
```

Destructuring assignment is like the reverse of an assignment. Imagine that we're writing this props object manually. The assignment might look something like this:

```
const props = { name: "Michael Chan", age: 33 }
```

When "destructuring" the assignment, you simply do the reverse. We omit the value because we can't know what it is.

```
const { name, age } = props
```

Now two new constants have been created. `name` evaluates to the string "Michael Chan" and `age` evaluates to the number 33.

This might take some getting used to.


## Click Counter

Now we'll update the bigger. In addition to the syntax we used for Greeting, we'll look at:

* method definition syntax
* Arrow functions bind this

### Const

First, and easiest. We switch the `var` for `const` to protect against reassignment.

```
var ClickCounter = React.createClass({
```

```
const ClickCounter = React.createClass({
```

### Method Definition syntax

ES2015 allows you to write method definitions much like any other language. Inside an object, you no longer have to write `: function`.

```
{ myMethod: function () { // do something } }
```

Method definitions look like this.

```
{ myMethod() { // do something } }
```

```
const ClickCounter = React.createClass({
  getInitialState() {
    return { clicks: 0 }
  },

  componentDidMount() {
    var component = this

    return setTimeout(function () {
      component.setState({ clicks: 100 })
    }, 500)
  },

  handleClick() {
     this.setState({ clicks: this.state.clicks + 1 })
  },

  render() {
    return <div onClick={this.handleClick}>
      {this.props.children}
      clicks: {this.state.clicks}
    </div>
  },
})
```

### Arrow function bind this

In `componentDidMount`, we're forced to keep a reference to `this` (component) that we then use inside our `setTimeout`. This is something we have to deal with for any asyncronous function.

```
  componentDidMount() {
    var component = this

    return setTimeout(function () {
      component.setState({ clicks: 100 })
    }, 500)
  },
```

Arrow functions bind this. By removing function, and using an arrow function here, we can preserve this, inside the function

```
  componentDidMount() {
    return setTimeout(() => {
      this.setState({ clicks: 100 })
    }, 500)
  },
```
